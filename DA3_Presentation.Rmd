---
title: "Stat 8330 Final Project"
author: "Katie Price, Emily Scully, Ben Graves, Ellen Fitzsimmons, and Mira Isnainy"
date: \today
output: beamer_presentation
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#install.packages("ncdf4")
#install.packages("raster")
#install.packages("rgdal")
#install.packages("ggplot2")
#install.packages("ncdf4.helpers")
#install.packages("PCICt")
library(ncdf4) # package for netcdf manipulation
library(raster) # package for raster manipulation
library(rgdal) # package for geospatial analysis
library(ggplot2) # package for plotting
library(ncdf4.helpers)
library(PCICt)
library(lubridate)
library(dplyr)
library(maps)
library(fields)
library(ggpubr)
library(kernlab)
library(NMF)
library(lle)
library(dimRed)
library(loe)
library(RSpectra)
library(reshape2)
```

```{r data, echo=FALSE}
## import data
# To load the RData
load("data_in_dfs.RData")

```

## Introduction

## Dimension Reduction and Clustering

- Dimension reduction
    - PCA
    - KPCA (Linear Kernel)
    - Local Linear Embedding (LLE)
    - Laplacian Eigenmaps (LE)
    
\vspace{4pt}

- Clustering
    - Assess number of clusters using clustering indices
    - Plot to see if clusters make sense

## SST Results
- PCA
    - Better than random: 33 PCs (97.5% Var)
    - 2 clusters suggested

\vspace{2pt}    
    
- KPCA
    - Better than random: 32 PCs (99.97% Var)
    - 6 PCs account for 97.41% of variance
    - 5 clusters
    

## SST Results

- LLE
    - 2 dimensions
    - 16 neighbors
    - 10 clusters
    
\vspace{2pt}

- LE
    - 2 dimensions
    - 3 clusters
    
```{r SSTSVDsetup, include=FALSE, cache=TRUE}
SST_df <- na.omit(SST_df)
SST_df <- apply(SST_df, 2, as.numeric)
LongLat <- SST_df[, 1:2]
MonthlySST <- SST_df[ , -c(1,2)]

form <- theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
              panel.background = element_blank(), axis.line = element_line(colour = "black"))

## Start with SVD to get an idea of Prin Comp needed
SSTSVD <- svd(MonthlySST)
SSTsingvals <- matrix(NA, nrow = 842, ncol = 2)
SSTsingvals[, 1] <- 1:842
SSTsingvals[, 2] <- SSTSVD$d
SVDvaracc <- cumsum(SSTSVD$d[1:33]^2)/sum(SSTSVD$d^2)*100


## Set up random data
set.seed(938837)
rand <- matrix(NA, 2512, 842)
for (i in 1:842) {
    rand[ , i] <- MonthlySST[sample(nrow(MonthlySST)), i]
}

randdecomp <- svd(rand)
SSTsingvals <- data.frame(SSTsingvals, as.numeric(randdecomp$d))
colnames(SSTsingvals) <- c('Component', 'Real Data Trace', 'Random Data Trace')

## PC DF
SSTUD <- SSTSVD$u %*% diag(SSTSVD$d)
SSTUD <- data.frame(LongLat, SSTUD[ , -c(34:842)])
colnames(SSTUD) <- c('Longitude', 'Latitude', paste0('PC', 1:33))

## Cluster
set.seed(662321)
SVDclustres <- kmeans(SSTUD[, -c(1, 2)], 2, nstart = 20, iter.max = 15)
SVDclustout <- data.frame(LongLat, Cluster = factor(SVDclustres$cluster))
colnames(SVDclustout) <- c('Longitude', 'Latitude', 'Cluster')
```

```{r loadothers, include=FALSE}
if (file.exists('SSTdimreduce.RData')){
    load('SSTdimreduce.RData')
} else {
    kpca2 <- kpca(MonthlySST, kernel = "vanilladot", kpar = list())
    kpcarand <- kpca(rand, kernel = "vanilladot", kpar = list())
    lleres <- lle(MonthlySST, m = 2, k = 16)
    LE <- embed(MonthlySST, .method = 'LaplacianEigenmaps')
    save(kpca2, kpcarand, lleres, LE, file = 'SSTdimreduce.RData')
}
```

```{r SSTKPCA, include = FALSE}
#kpca2 <- kpca(MonthlySST, kernel = "vanilladot", kpar = list()) 
SSTkpcavar <- cumsum(kpca2@eig[1:32]^2)/sum(kpca2@eig^2)*100
#kpcarand <- kpca(rand, kernel = "vanilladot", kpar = list())
kpcaeig <- data.frame(Component = 1:162, Real = kpca2@eig, Random = kpcarand@eig[1:162])
colnames(kpcaeig) <- c('Component', 'Real Data Trace', 'Random Data Trace')
kpcaeig<- melt(kpcaeig, id.vars = 'Component', 
                    variable.name = 'Data', value.name = 'EigenVal')


KPCApcs <- kpca2@pcv[ , 1:6]
KPCApcs <- data.frame(LongLat, KPCApcs)
colnames(KPCApcs) <- c('Longitude', 'Latitude', paste0('PC', 1:6))

set.seed(662321)
## Suggests 5
KPCAclustres <- kmeans(KPCApcs[, -c(1,2)], 5, nstart = 20, iter.max = 15) 
KPCAclustout <- data.frame(LongLat, Cluster = factor(KPCAclustres$cluster))
colnames(KPCAclustout) <- c('Longitude', 'Latitude', 'Cluster')
```

```{r SSTLLE, include=FALSE}
# lleres <- lle(MonthlySST, m = 2, k = 16)
# LE <- embed(MonthlySST, .method = 'LaplacianEigenmaps')

Ymat <- data.frame(lleres$Y)
LEout <- data.frame(Obs = 1:2512, LE@data@data)

set.seed(662321)
LLEclustres <- kmeans(Ymat, 10, nstart = 20, iter.max = 15)
LLEclustout <- data.frame(LongLat, Cluster = factor(LLEclustres$cluster))
colnames(LLEclustout) <- c('Longitude', 'Latitude', 'Cluster')

set.seed(662321)
LEclustres <- kmeans(LEout[, -1], 3, nstart = 20, iter.max = 15) ## suggests 2 or 3 clusters
LEclustout <- factor(LEclustres$cluster)
LEclustout <- data.frame(LongLat, Cluster = factor(LEclustres$cluster))
colnames(LEclustout) <- c('Longitude', 'Latitude', 'Cluster')
```

## SST PC1 Plots

```{r SSTPC1, echo=FALSE, results='asis', fig.cap = '\\label{fig:SSTPC1s} Plot of PC1 from PCA and KPCA for SST data.', fig.align = 'center', out.height='70%'}
## Plot PC 1
SSTSVDPC1 <- ggplot(SSTUD, aes(x = Longitude, y = Latitude, fill = PC1)) + 
             coord_fixed(ratio = 1) + geom_raster(alpha = 1) + form + 
             scale_fill_gradientn(na.value = "white", colours = c("yellow", "orange", "green", "blue")) +
             ggtitle('PCA PC1')

## Plot PC 1
SSTkpcaPC1 <- ggplot(KPCApcs, aes(x = Longitude, y = Latitude, fill = PC1)) + 
              coord_fixed(ratio = 1) + geom_raster(alpha = 1) + form + 
              scale_fill_gradientn(na.value = "white", colours = c("yellow", "orange", "green", "blue")) +
              ggtitle('KPCA PC1')

ggarrange(SSTSVDPC1, SSTkpcaPC1, ncol = 1, nrow = 2)
```

## SST Cluster Plots

```{r clusterplot1, echo = FALSE, results='asis', fig.cap = '\\label{fig:SSTClusters} Best clustering solutions for each of the dimension reduction methods for SST data.', fig.align = 'center', out.height='60%'}
## SVD plot
SSTSVDClust <- ggplot(SVDclustout, aes(x = Longitude, y = Latitude,  fill = Cluster)) + 
               coord_fixed(ratio = 1) + geom_raster(alpha = 1) + form + ggtitle('Clustering from PCA') +
                theme(legend.key.size = unit(.5, 'cm'),
                     legend.key.height = unit(.5, 'cm'),
                     legend.key.width = unit(.5, 'cm'),
                     legend.title = element_text(size=10),
                     legend.text = element_text(size=8)) 

## KPCA plot
SSTKPCAClust <- ggplot(KPCAclustout, aes(x = Longitude, y = Latitude,  fill = Cluster)) +
                coord_fixed(ratio = 1) + geom_raster(alpha = 1) + form + ggtitle('Clustering from KPCA') +
                theme(legend.key.size = unit(.5, 'cm'),
                     legend.key.height = unit(.5, 'cm'),
                     legend.key.width = unit(.5, 'cm'),
                     legend.title = element_text(size=10),
                     legend.text = element_text(size=8)) 

## LLE plot
SSTLLEClust <- ggplot(LLEclustout, aes(x = Longitude, y = Latitude,  fill = Cluster)) + 
               coord_fixed(ratio = 1) + geom_raster(alpha = 1) + form + ggtitle('Clustering from LLE') +
               theme(legend.key.size = unit(.5, 'cm'),
                     legend.key.height = unit(.5, 'cm'),
                     legend.key.width = unit(.5, 'cm'),
                     legend.title = element_text(size=10),
                     legend.text = element_text(size=8)) + guides(fill=guide_legend(ncol=2))

## LE plot
SSTLEClust <- ggplot(LEclustout, aes(x = Longitude, y = Latitude,  fill = Cluster)) + 
              coord_fixed(ratio = 1) + geom_raster(alpha = 1) + form + ggtitle('Clustering from LE') +
              theme(legend.key.size = unit(.5, 'cm'),
                     legend.key.height = unit(.5, 'cm'),
                     legend.key.width = unit(.5, 'cm'),
                     legend.title = element_text(size=10),
                     legend.text = element_text(size=8)) 

ggarrange(SSTSVDClust, SSTKPCAClust, SSTLLEClust, SSTLEClust, ncol = 2, nrow = 2)
```

## SST Cluster Location on First Two Dimensions

```{r clustbypc, echo = FALSE, results='asis', fig.cap = '\\label{fig:SSTClustbypc} Location clusters plotted by the first two PCs or manifolds of each dimension reduction techinque.', fig.align = 'center', out.height='60%'}
SSTSVDPCplot <- ggplot(data = data.frame(SSTUD, SVDclustout), aes(x = PC1, y = PC2, color = Cluster)) + 
                geom_point(size = .3) + form + xlab('Principal Component 1') + 
                ylab('Principal Component 2') + ggtitle('PCA Clusters') +
                theme(legend.key.size = unit(.25, 'cm'),
                     legend.key.height = unit(.25, 'cm'),
                     legend.key.width = unit(.25, 'cm'),
                     legend.title = element_text(size=8),
                     legend.text = element_text(size=6)) 

SSTKPCAPCplot <- ggplot(data = data.frame(KPCApcs, KPCAclustout), 
                        aes(x = PC1, y = PC2, color = Cluster)) + 
                 geom_point(size = .3) + form + xlab('Principal Component 1') + 
                 ylab('Principal Component 2') + ggtitle('KPCA Clusters') +
                 theme(legend.key.size = unit(.25, 'cm'),
                     legend.key.height = unit(.25, 'cm'),
                     legend.key.width = unit(.25, 'cm'),
                     legend.title = element_text(size=8),
                     legend.text = element_text(size=6)) 

SSTLLEdimplot <- ggplot(data = data.frame(Ymat, LLEclustout), aes(x = Ymat[, 1], y = Ymat[, 2], color = Cluster)) +
                 geom_point(size = .3) + form + xlab('Dimension 1') + 
                 ylab('Dimension 2') + ggtitle('LLE Clusters') +
                 theme(legend.key.size = unit(.25, 'cm'),
                     legend.key.height = unit(.25, 'cm'),
                     legend.key.width = unit(.25, 'cm'),
                     legend.title = element_text(size=8),
                     legend.text = element_text(size=6)) + guides(fill=guide_legend(ncol=2))

SSTLEmanifolds <- ggplot(data = data.frame(LEout, LEclustout), aes(x = LEout[, 1], y = LEout[, 2], color = Cluster)) +
                  geom_point(size = .3) + form + xlab('Manifold 1') + 
                  ylab('Manifold 2') + ggtitle('LE Clusters') +
                  theme(legend.key.size = unit(.25, 'cm'),
                     legend.key.height = unit(.25, 'cm'),
                     legend.key.width = unit(.25, 'cm'),
                     legend.title = element_text(size=8),
                     legend.text = element_text(size=6)) 

ggarrange(SSTSVDPCplot, SSTKPCAPCplot, SSTLLEdimplot, SSTLEmanifolds, ncol = 2, nrow = 2)
```

```{r cleanup, include=FALSE}
remove(kpca2, kpcarand, lleres, LE, SSTSVD, randdecomp, MonthlySST, rand)
```

## Precipitation Results

- PCA
    - Better than random: 26 PCs (95.63% Var)
    - 4 clusters selected
    
\vspace{2pt}

- KPCA
    - Better than random: 25 PCs (99.95% Var)
    - 4 PCs account for 98.4% of variance
    - 12 clusters
    

## Precipitation Results

- LLE
    - 2 dimensions
    - 25 neighbors
    - 3 clusters
    
\vspace{2pt}

- LE
    - 2 dimensions
    - 3 clusters

```{r precipsetup, include=FALSE}
Pdat_df <- na.omit(Pdat_df)
Pdat_df <- apply(Pdat_df, 2, as.numeric)
LongLat2 <- Pdat_df[, 1:2]
MonthlyPrecip <- Pdat_df[ , -c(1,2)]

## Start with SVD to get an idea of Prin Comp needed
PrecipSVD <- svd(MonthlyPrecip)
Precipsingvals <- matrix(NA, nrow = 842, ncol = 2)
Precipsingvals[, 1] <- 1:842
Precipsingvals[, 2] <- PrecipSVD$d
PrecipSVDvaracc <- cumsum(PrecipSVD$d[1:26]^2)/sum(PrecipSVD$d^2)*100

## Set up random data
set.seed(374378)
rand2 <- matrix(NA, 5390, 842)
for (i in 1:842) {
    rand2[ , i] <- MonthlyPrecip[sample(nrow(MonthlyPrecip)), i]
}

rand2decomp <- svd(rand2)
Precipsingvals <- data.frame(Precipsingvals, as.numeric(rand2decomp$d))
colnames(Precipsingvals) <- c('Component', 'Real Data Trace', 'Random Data Trace')


## set up PCs
PrecipUD <- PrecipSVD$u %*% diag(PrecipSVD$d)
PrecipUD <- data.frame(LongLat2, PrecipUD[ , -c(27:842)])
colnames(PrecipUD) <- c('Longitude', 'Latitude', paste0('PC', 1:26))

## Cluster
set.seed(629787)
PSVDclustres <- kmeans(PrecipUD[, -c(1, 2)], 4, nstart = 20, iter.max = 20) ## 2 or 4 suggested as best
PSVDclustout <- data.frame(LongLat2, Cluster = factor(PSVDclustres$cluster))
colnames(PSVDclustout) <- c('Longitude', 'Latitude', 'Cluster')
```

```{r loadothers2, include=FALSE}
if (file.exists('Precipdimreduce.RData')){
    load('Precipdimreduce.RData')
} else {
    Pkpca2 <- kpca(MonthlySST, kernel = "vanilladot", kpar = list())
    Pkpcarand <- kpca(rand, kernel = "vanilladot", kpar = list())
    Plleres <- lle(MonthlySST, m = 2, k = 16)
    PLE <- embed(MonthlySST, .method = 'LaplacianEigenmaps')
    save(Pkpca2, Pkpcarand2, Plleres, PLE, file = 'Precipdimreduce.RData')
}
```

```{r precipkpca, include=FALSE}
#Pkpca2 <- kpca(MonthlyPrecip, kernel = "vanilladot", kpar = list()) ##maybe 2-4 PCs? Better than Random suggests 25.
Pkpcavaracc <- cumsum(Pkpca2@eig[1:26]^2)/sum(Pkpca2@eig^2)*100
#Pkpcarand2 <- kpca(rand2, kernel = "vanilladot", kpar = list())
Pkpcaeig <- data.frame(Component = 1:842, Real = Pkpca2@eig, Random = Pkpcarand2@eig)
colnames(Pkpcaeig) <- c('Component', 'Real Data Trace', 'Random Data Trace')
Pkpcaeig<- melt(Pkpcaeig, id.vars = 'Component', 
                    variable.name = 'Data', value.name = 'EigenVal')

PKPCApcs <- Pkpca2@pcv[ , 1:4]

## Cluster
## 12 Suggested
set.seed(662321)
PKPCAclustres <- kmeans(PKPCApcs, 12, nstart = 20, iter.max = 15)
PKPCAclustout <- data.frame(LongLat2, Cluster = factor(PKPCAclustres$cluster))
colnames(PKPCAclustout) <- c('Longitude', 'Latitude', 'Cluster')

PKPCApcs <- data.frame(LongLat2, PKPCApcs)
colnames(PKPCApcs) <- c('Longitude', 'Latitude', paste0('PC', 1:4))
```

```{r precipLLE, include=FALSE}
## Opt K = 25 for 2
#Plleres <- lle(MonthlyPrecip, m = 2, k = 25)
PYmat <- data.frame(Plleres$Y)

## Cluster
set.seed(662321)
PLLEclustres <- kmeans(PYmat, 3, nstart = 20, iter.max = 25) #3 suggested, 2 next
PLLEclustout <- data.frame(LongLat2, Cluster = factor(PLLEclustres$cluster))
colnames(PLLEclustout) <- c('Longitude', 'Latitude', 'Cluster')
```

```{r precipLE, include=FALSE}
#PLE <- embed(MonthlyPrecip, .method = 'LaplacianEigenmaps')
PLEout <- data.frame(Obs = 1:5390, PLE@data@data)


## Cluster
set.seed(662321)
PLEclustres <- kmeans(PLEout[, -1], 3, nstart = 20, iter.max = 20) ## suggests 2 or 3 clusters
PLEclustout <- data.frame(LongLat2, Cluster = factor(PLEclustres$cluster))
colnames(PLEclustout) <- c('Longitude', 'Latitude', 'Cluster')
```

## Precipitation PC1s

```{r PrecipPC1, echo=FALSE, results='asis', fig.cap = '\\label{fig:PrecipPC1s} Plot of PC1 from PCA and KPCA for precipitation data.', fig.align = 'center', out.height='70%'}
bmap = map_data("state")
colnames(bmap)[1:2] <- c('Longitude', 'Latitude')

## Plot PC 1
PrecipSVDPC1 <- ggplot(PrecipUD, aes(x = Longitude, y = Latitude, fill = PC1)) + 
                coord_fixed(ratio = 1) + 
                geom_raster(alpha = 1) + 
                geom_polygon(data = bmap,
                             aes(x = Longitude, y = Latitude, group = group),
                             inherit.aes = F, colour = 'black', 
                             fill = NA, lwd = 0.5) + 
                form + scale_fill_gradientn(na.value = "white", 
                                            colours = c("yellow", "orange", "green", "blue")) +
                ggtitle('PCA PC1')

## Plot PC 1
PrecipkpcaPC1 <- ggplot(PKPCApcs, aes(x = Longitude, y = Latitude, fill = PC1)) + 
                 coord_fixed(ratio = 1) + 
                 geom_raster(alpha = 1) +
                 geom_polygon(data = bmap,
                              aes(x = Longitude, y = Latitude, group = group),
                              inherit.aes = F, colour = 'black', 
                              fill = NA, lwd = 0.5) +
                 form + 
                 scale_fill_gradientn(na.value = "white", 
                                      colours = c("yellow", "orange", "green", "blue")) +
                 ggtitle('KPCA PC1')

ggarrange(PrecipSVDPC1, PrecipkpcaPC1, ncol = 1, nrow = 2)
```

## Precipitation Cluster Plots

```{r clusterplot2, echo = FALSE, results='asis', fig.cap = '\\label{fig:PrecipClusters} Best clustering solutions for each of the dimension reduction methods for Precipitation data.', fig.align = 'center', out.height='60%'}
## SVD plot
PrecipSVDClust <- ggplot(PSVDclustout, aes(x = Longitude, y = Latitude,  fill = Cluster)) + 
                  coord_fixed(ratio = 1) + geom_raster(alpha = 1) +
                  geom_polygon(data = bmap,
                             aes(x = Longitude, y = Latitude, group = group),
                             inherit.aes = F, colour = 'black', 
                             fill = NA, lwd = 0.5) +
                  form + ggtitle('Clustering from PCA') +
                  theme(legend.key.size = unit(.5, 'cm'),
                        legend.key.height = unit(.5, 'cm'),
                        legend.key.width = unit(.5, 'cm'),
                        legend.title = element_text(size=10),
                        legend.text = element_text(size=8)) 

## KPCA plot
PrecipKPCAClust <- ggplot(PKPCAclustout, aes(x = Longitude, y = Latitude,  fill = Cluster)) +
                   coord_fixed(ratio = 1) + geom_raster(alpha = 1) + 
                   geom_polygon(data = bmap,
                             aes(x = Longitude, y = Latitude, group = group),
                             inherit.aes = F, colour = 'black', 
                             fill = NA, lwd = 0.5) +
                   form + ggtitle('Clustering from KPCA') +
                   theme(legend.key.size = unit(.5, 'cm'),
                         legend.key.height = unit(.5, 'cm'),
                         legend.key.width = unit(.5, 'cm'),
                         legend.title = element_text(size=10),
                         legend.text = element_text(size=8)) + guides(fill=guide_legend(ncol=2))

## LLE plot
PrecipLLEClust <- ggplot(PLLEclustout, aes(x = Longitude, y = Latitude,  fill = Cluster)) + 
                  coord_fixed(ratio = 1) + geom_raster(alpha = 1) + 
                  geom_polygon(data = bmap,
                             aes(x = Longitude, y = Latitude, group = group),
                             inherit.aes = F, colour = 'black', 
                             fill = NA, lwd = 0.5) +
                  form + ggtitle('Clustering from LLE') +
                  theme(legend.key.size = unit(.5, 'cm'),
                        legend.key.height = unit(.5, 'cm'),
                        legend.key.width = unit(.5, 'cm'),
                        legend.title = element_text(size=10),
                        legend.text = element_text(size=8))

## LE plot
PrecipLEClust <- ggplot(PLEclustout, aes(x = Longitude, y = Latitude,  fill = Cluster)) + 
                 coord_fixed(ratio = 1) + geom_raster(alpha = 1) + 
                 geom_polygon(data = bmap,
                             aes(x = Longitude, y = Latitude, group = group),
                             inherit.aes = F, colour = 'black', 
                             fill = NA, lwd = 0.5) +
                 form + ggtitle('Clustering from LE') +
                 theme(legend.key.size = unit(.5, 'cm'),
                       legend.key.height = unit(.5, 'cm'),
                       legend.key.width = unit(.5, 'cm'),
                       legend.title = element_text(size=10),
                       legend.text = element_text(size=8)) 

ggarrange(PrecipSVDClust, PrecipKPCAClust, PrecipLLEClust, PrecipLEClust, ncol = 2, nrow = 2)
```

## Precipitation Cluster Location on First Two Dimensions

```{r clustbypc2, echo = FALSE, results='asis', fig.cap = '\\label{fig:PrecipClustbypc} Location clusters plotted by the first two PCs or manifolds of each dimension reduction techinque.', fig.align = 'center', out.height='60%'}
PrecipSVDPCplot <- ggplot(data = data.frame(PrecipUD, PSVDclustout), aes(x = PC1, y = PC2, color = Cluster)) + 
                   geom_point(size = .3) + form + xlab('Principal Component 1') + 
                   ylab('Principal Component 2') + ggtitle('PCA Clusters') +
                   theme(legend.key.size = unit(.25, 'cm'),
                         legend.key.height = unit(.25, 'cm'),
                         legend.key.width = unit(.25, 'cm'),
                         legend.title = element_text(size=8),
                         legend.text = element_text(size=6)) 

PrecipKPCAPCplot <- ggplot(data = data.frame(PKPCApcs, PKPCAclustout), 
                        aes(x = PC1, y = PC2, color = Cluster)) + 
                    geom_point(size = .3) + form + xlab('Principal Component 1') + 
                    ylab('Principal Component 2') + ggtitle('KPCA Clusters') +
                    theme(legend.key.size = unit(.25, 'cm'),
                          legend.key.height = unit(.25, 'cm'),
                          legend.key.width = unit(.25, 'cm'),
                          legend.title = element_text(size=8),
                          legend.text = element_text(size=6)) 

PrecipLLEdimplot <- ggplot(data = data.frame(PYmat, PLLEclustout), aes(x =  PYmat[, 1], y = PYmat[, 2], color = Cluster)) +
                    geom_point(size = .3) + form + xlab('Dimension 1') + 
                    ylab('Dimension 2') + ggtitle('LLE Clusters') +
                    theme(legend.key.size = unit(.25, 'cm'),
                          legend.key.height = unit(.25, 'cm'),
                          legend.key.width = unit(.25, 'cm'),
                          legend.title = element_text(size=8),
                          legend.text = element_text(size=6)) + guides(fill=guide_legend(ncol=2))

PrecipLEmanifolds <- ggplot(data = data.frame(PLEout, PLEclustout), aes(x = PLEout[, 1], y = PLEout[, 2], color = Cluster)) +
                     geom_point(size = .3) + form + xlab('Manifold 1') + 
                     ylab('Manifold 2') + ggtitle('LE Clusters') +
                     theme(legend.key.size = unit(.25, 'cm'),
                           legend.key.height = unit(.25, 'cm'),
                           legend.key.width = unit(.25, 'cm'),
                           legend.title = element_text(size=8),
                           legend.text = element_text(size=6)) 

ggarrange(PrecipSVDPCplot, PrecipKPCAPCplot, PrecipLLEdimplot, PrecipLEmanifolds, ncol = 2, nrow = 2)
```

<!-- # ```{r cleanup2, include = FALSE} -->
<!-- # remove(PrecipSVD, rand2decomp, Pkpca2, Pkpcarand2, Plleres, PLE, MonthlyPrecip, rand2) -->
<!-- # ``` -->


## Methods

- We created baseline models with climatology predictions and a persistence model



```{r clim_mod, echo=FALSE, cache=TRUE}
# Climatology Predictions (average of all previous months) ##############

# All months through 2016
Pdat_df_train = Pdat_df[,1:grep(pattern = "Dec2016", x = names(Pdat_df))]

# All months in 2017 only
Pdat_df_test = Pdat_df[, c(grep(pattern = "2017", x = names(Pdat_df)))]
Pdat_df_test = cbind(Pdat_df[,c("long", "lat")], Pdat_df_test)

# Predict using climatology method (average of all previous months)
Pdat_df_preds = data.frame(Pdat_df_train[,c("long", "lat")])
for(i in month.abb) {
  Pdat_df_preds[, paste0(i, "2017pred")] =
    rowMeans(Pdat_df_train[, grep(pattern = i,
                                  x = names(Pdat_df_train))])
}

# MSE from climatology predictions (average of all previous months)
MSE_clim = vector()
for(i in month.abb) {
  MSE_clim[i] = colMeans(((Pdat_df_test[grep(pattern = i,
                                        x = names(Pdat_df_test))] -
                        Pdat_df_preds[, grep(pattern = i,
                                             x = names(Pdat_df_preds))]) ^ 2),
                    na.rm = TRUE)
}

```

## Climatology Predictions: January Predictions

```{r clim_mod_plot_1, echo=FALSE, cache=TRUE}
# Plot of the January predictions
Jan2017Pred_raster <- rasterFromXYZ(Pdat_df_preds[, c("long", "lat", "Jan2017pred")])
plot(Jan2017Pred_raster)

```

## Climatology Predictions: January True Values

```{r clim_mod_plot_2, echo=FALSE, cache=TRUE}
# Plot of the January true values
Jan2017True_raster <- rasterFromXYZ(Pdat_df_test[, c("long", "lat", "Jan2017")])
plot(Jan2017True_raster)

```

## Climatology Predictions

```{r clim_mod_plot_3, echo=FALSE, cache=TRUE}
state_map = map_data("state")
bmap = map_data("state")


# Fancy plots
ggplot() +
  coord_fixed(ratio = 1) +
  geom_raster(data = Pdat_df_preds,
              aes(x = long, y = lat, fill = May2017pred),
              alpha = 1) +
  geom_polygon(
    data = bmap,
    aes(x = long, y = lat, group = group),
    inherit.aes = F,
    colour = 'black',
    fill = NA,
    lwd = 0.5
  ) +
  scale_fill_gradientn(
    na.value = "white",
    # Limits need to be updated accordingly
    limits = c(min(Pdat_df_preds$May2017pred) - 0.5, 
               max(Pdat_df_preds$May2017pred) + 0.5),
    colours = c("blue", "green", "orange", "yellow")
  )+
  theme(
    axis.title.x = element_blank(),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.title.y = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(colour = "black",
                                fill = NA,
                                size = 0.5),
    panel.background = element_blank()
  ) + 
  labs(fill = "Precipication \nUnits", 
       title = "May 2017 Predicted Precipitation")

```

## Persistence Model

```{r pers_mod, echo=FALSE, cache=TRUE, message=FALSE}
# Persistence Predictions (pred_(t + tau) = pred_t) ##############


# Need to define how far out we want tau to be
# Project document suggests 6 months?

## I based this on the following tutorial:
# https://machinelearningmastery.com/persistence-time-series-forecasting-with-python/


## Step 1
## transform univariate dataset into supervised learning problem
## load the data set and create a lagged representation
## i.e. given the observation at t predict the observation at t + tau
predprecip <- function(df, tau){
  ## df is dataframe
  ## tau is distance from prediction point
  mat <- as.matrix(df)
  predprecip <- matrix(NA, nrow = nrow(mat), ncol = ncol(mat) + tau)
  colnames(predprecip) <- c(colnames(mat), c(paste("x", 1:tau, sep = "")))
  for(i in 1:ncol(mat)){
    if(i < 3){
      predprecip[, i] <- mat[, i]
    } else{
      ttau <- i + tau
      predprecip[, ttau] <- mat[, i]
    }
  }
  preddf <- as.data.frame(predprecip)
  return(preddf)
}

## predicted precipitations when tau = 6 months
preddf <- predprecip(Pdat_df, 6)

## Step 2
## establish train and test datasets for test harness
## This isn't necessary, but if we want to add it we can

## Step 3
## Define persistence model
## This step is also unnecessary because we can extract it from step 1

## Step 4
## Make forecast and establish baseline performance
library(tidyr)
testmse <- function(Pdat_df, preddf){
  longdatorig <- gather(Pdat_df, time, precip, 3:ncol(Pdat_df))
  longdatpred <- gather(preddf, time, precip, 3:ncol(preddf))
  
  y <- data.frame("ytest" = longdatorig$precip, "yhat" = longdatpred[1:nrow(longdatorig), ]$precip)
  y <- na.omit(y)
  testmse <- mean((y$yhat - y$ytest)^2)
  return(testmse)
}

```

```{r pers_mod_plot, echo=FALSE, cache=TRUE}
## It seems MSE increases as tau approaches the 6 months mark and decreases 
## as it approaches the 12 month mark
n <- 24
msemat <- matrix(c(1:n, rep(NA, n)), nrow = n, ncol = 2, byrow = FALSE)
colnames(msemat) <- c("tau", "mse")
for(i in 1:n){
  preddf <- predprecip(Pdat_df, i)
  msemat[i, 2] <- testmse(Pdat_df, preddf)
}

ggplot(data=as.data.frame(msemat), aes(x=tau, y=mse, group=1)) +
  geom_line()+
  geom_point() +
  xlab("tau: Number of Months Ahead of Prediction") +
  ylab("Test MSE") +
  labs(title = "Test MSE for Varying Values of tau")

```


## Results

## Conclusions
